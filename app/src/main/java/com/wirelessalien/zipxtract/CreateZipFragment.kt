/* *  Copyright (C) 2023  WirelessAlien <https://github.com/WirelessAlien> * *     This program is free software: you can redistribute it and/or modify *     it under the terms of the GNU General Public License as published by *     the Free Software Foundation, either version 3 of the License, or *     any later version. * *     This program is distributed in the hope that it will be useful, *     but WITHOUT ANY WARRANTY; without even the implied warranty of *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *     GNU General Public License for more details. * *     You should have received a copy of the GNU General Public License *     along with this program.  If not, see <https://www.gnu.org/licenses/>. */package com.wirelessalien.zipxtractimport android.annotation.SuppressLintimport android.app.Activity.RESULT_OKimport android.content.Contextimport android.content.Intentimport android.content.SharedPreferencesimport android.net.Uriimport android.os.Buildimport android.os.Bundleimport android.provider.DocumentsContractimport android.provider.OpenableColumnsimport android.system.ErrnoExceptionimport android.system.OsConstantsimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.widget.AdapterViewimport android.widget.ArrayAdapterimport android.widget.CheckBoximport android.widget.EditTextimport android.widget.Spinnerimport android.widget.Toastimport androidx.activity.result.contract.ActivityResultContractsimport androidx.appcompat.app.AppCompatActivityimport androidx.documentfile.provider.DocumentFileimport androidx.fragment.app.Fragmentimport androidx.lifecycle.lifecycleScopeimport androidx.recyclerview.widget.LinearLayoutManagerimport androidx.recyclerview.widget.RecyclerViewimport androidx.transition.TransitionInflaterimport com.google.android.material.dialog.MaterialAlertDialogBuilderimport com.google.android.material.snackbar.Snackbarimport com.wirelessalien.zipxtract.databinding.FragmentCreateZipBindingimport kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.launchimport kotlinx.coroutines.withContextimport net.lingala.zip4j.ZipFileimport net.lingala.zip4j.exception.ZipExceptionimport net.lingala.zip4j.model.ZipParametersimport net.lingala.zip4j.model.enums.AesKeyStrengthimport net.lingala.zip4j.model.enums.CompressionLevelimport net.lingala.zip4j.model.enums.CompressionMethodimport net.lingala.zip4j.model.enums.EncryptionMethodimport net.sf.sevenzipjbinding.ICryptoGetTextPasswordimport net.sf.sevenzipjbinding.IOutCreateCallbackimport net.sf.sevenzipjbinding.IOutFeatureSetEncryptHeaderimport net.sf.sevenzipjbinding.IOutItem7zimport net.sf.sevenzipjbinding.ISequentialInStreamimport net.sf.sevenzipjbinding.SevenZipimport net.sf.sevenzipjbinding.SevenZipExceptionimport net.sf.sevenzipjbinding.impl.OutItemFactoryimport net.sf.sevenzipjbinding.impl.RandomAccessFileInStreamimport net.sf.sevenzipjbinding.impl.RandomAccessFileOutStreamimport java.io.Fileimport java.io.FileInputStreamimport java.io.FileOutputStreamimport java.io.IOExceptionimport java.io.RandomAccessFileclass CreateZipFragment : Fragment(),  FileAdapter.OnDeleteClickListener, FileAdapter.OnFileClickListener {	private lateinit var binding: FragmentCreateZipBinding	private var outputDirectory: DocumentFile? = null	private var pickedDirectory: DocumentFile? = null	private lateinit var sharedPreferences: SharedPreferences	private lateinit var prefs: SharedPreferences	private val tempFiles = mutableListOf<File>()	private var selectedFileUri: Uri? = null	private val cachedFiles = mutableListOf<File>()	private var cachedDirectoryName: String? = null	private lateinit var recyclerView: RecyclerView	private lateinit var adapter: FileAdapter	private lateinit var fileList: MutableList<File>	private var cacheFile: File? = null	private val pickFilesLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->		if (result.resultCode == RESULT_OK) {			if (result.data != null) {				val clipData = result.data!!.clipData				if (clipData != null) {					tempFiles.clear()					binding.circularProgressBar.visibility = View.VISIBLE					CoroutineScope(Dispatchers.IO).launch {						for (i in 0 until clipData.itemCount) {							val filesUri = clipData.getItemAt(i).uri							val cursor = requireActivity().contentResolver.query(filesUri, null, null, null, null)							if (cursor != null && cursor.moveToFirst()) {								val displayNameIndex = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME)								val displayName = cursor.getString(displayNameIndex)								val tempFile = File(requireContext().cacheDir, displayName)								// Copy the content from the selected file URI to a temporary file								requireActivity().contentResolver.openInputStream(filesUri)?.use { input ->									tempFile.outputStream().use { output ->										input.copyTo(output)									}								}								tempFiles.add(tempFile)								// show picked files name								val selectedFilesText = getString(R.string.selected_files_text, tempFiles.size)								withContext(Dispatchers.Main) {									binding.fileNameTextView.text = selectedFilesText									binding.fileNameTextView.isSelected = true								}								cursor.close()							}						}						// Hide the progress bar on the main thread						withContext(Dispatchers.Main) {							binding.circularProgressBar.visibility = View.GONE							val fileList = getFilesInCacheDirectory(requireContext().cacheDir)							adapter.updateFileList(fileList)						}					}				}			}		}	}	private val pickFileLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->		if (result.resultCode == RESULT_OK) {			selectedFileUri = result.data?.data			if (selectedFileUri != null) {				showToast(getString(R.string.file_picked_success))				binding.createZipMBtn.isEnabled = true				binding.circularProgressBar.visibility = View.VISIBLE				// Display the file name from the intent				val fileName = getZipFileName(selectedFileUri!!)				val selectedFileText = getString(R.string.selected_file_text, fileName)				binding.fileNameTextView.text = selectedFileText				binding.fileNameTextView.isSelected = true				// Copy the file to the cache directory in background				CoroutineScope(Dispatchers.IO).launch {					cacheFile = File(requireContext().cacheDir, fileName)					cacheFile!!.outputStream().use { cache ->						requireContext().contentResolver.openInputStream(selectedFileUri!!)?.use { it.copyTo(cache) }					}					withContext(Dispatchers.Main) {						binding.circularProgressBar.visibility = View.GONE					}				}			} else {				showToast(getString(R.string.file_picked_fail))			}		}	}	private val directoryFilesPicker = registerForActivityResult(ActivityResultContracts.OpenDocumentTree()) { uri ->		uri?.let {			requireActivity().contentResolver.takePersistableUriPermission(it, Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION)			pickedDirectory = DocumentFile.fromTreeUri(requireContext(), uri)			copyFilesToCache(uri)			val directoryName = pickedDirectory?.name			binding.fileNameTextView.text = directoryName			binding.fileNameTextView.isSelected = true		}	}	private val directoryPicker = registerForActivityResult(ActivityResultContracts.OpenDocumentTree()) { uri ->		uri?.let {			requireActivity().contentResolver.takePersistableUriPermission(it, Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION)			outputDirectory = DocumentFile.fromTreeUri(requireContext(), uri)			val fullPath = outputDirectory?.uri?.path			val displayedPath = fullPath?.replace("/tree/primary", "")			if (displayedPath != null) {				val directoryText = getString(R.string.directory_path, displayedPath)				binding.directoryTextView.text = directoryText			}			// Save the output directory URI in SharedPreferences			val editor = sharedPreferences.edit()			editor.putString("outputDirectoryUriZip", uri.toString())			editor.apply()		}	}	override fun onCreateView(		inflater: LayoutInflater, container: ViewGroup?,		savedInstanceState: Bundle?,	): View {		binding = FragmentCreateZipBinding.inflate(inflater, container, false)		return binding.root	}	override fun onViewCreated(view: View, savedInstanceState: Bundle?) {		super.onViewCreated(view, savedInstanceState)		val inflater = TransitionInflater.from(requireContext())		exitTransition = inflater.inflateTransition(R.transition.slide_right)		sharedPreferences = requireActivity().getSharedPreferences("prefs", AppCompatActivity.MODE_PRIVATE)		prefs = requireActivity().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)		fileList = getFilesInCacheDirectory(requireContext().cacheDir)		binding.progressBar.visibility = View.GONE		binding.circularProgressBar.visibility = View.GONE		binding.progressBarNI.visibility = View.GONE		binding.pickFileButton.setOnClickListener {			val intent = Intent(Intent.ACTION_OPEN_DOCUMENT)			intent.addCategory(Intent.CATEGORY_OPENABLE)			intent.type = "*/*"			pickFileLauncher.launch(intent)			val cacheDir = requireContext().cacheDir			if (cacheDir.isDirectory) {				val children: Array<String> = cacheDir.list()!!				for (i in children.indices) {					File(cacheDir, children[i]).deleteRecursively()				}			}		}		binding.pickFilesButton.setOnClickListener {			openFile()			val cacheDir = requireContext().cacheDir			if (cacheDir.isDirectory) {				val children: Array<String> = cacheDir.list()!!				for (i in children.indices) {					File(cacheDir, children[i]).deleteRecursively()				}			}		}		binding.changeDirectoryButton.setOnClickListener {			chooseOutputDirectory()		}		binding.pickFolderButton.setOnClickListener {			changeDirectoryFilesPicker()			val cacheDir = requireContext().cacheDir			if (cacheDir.isDirectory) {				val children: Array<String> = cacheDir.list()!!				for (i in children.indices) {					File(cacheDir, children[i]).deleteRecursively()				}			}		}		binding.zipSettingsBtn.setOnClickListener {			//show alert dialog with settings		}		binding.settingsInfo.setOnClickListener {			//show alert dialog with info			MaterialAlertDialogBuilder(requireContext())				.setMessage(getString(R.string.settings_info_text))				.setPositiveButton(getString(R.string.ok)) { dialog, _ ->					dialog.dismiss()				}				.show()		}		binding.clearCacheBtnDP.setOnClickListener {			val editor = sharedPreferences.edit()			editor.putString("outputDirectoryUriZip", null)			editor.apply()			// clear output directory			outputDirectory = null			binding.directoryTextView.text = getString(R.string.no_directory_selected)			binding.directoryTextView.isSelected = false			showToast(getString(R.string.output_directory_cleared))		}		binding.clearCacheBtnPF.setOnClickListener {			//delete the complete cache directory folder, files and subdirectories			val cacheDir = requireContext().cacheDir			if (cacheDir.isDirectory) {				val children: Array<String> = cacheDir.list()!!				for (i in children.indices) {					File(cacheDir, children[i]).deleteRecursively()				}			}			val fileList = getFilesInCacheDirectory(requireContext().cacheDir)			adapter.updateFileList(fileList)			selectedFileUri = null			binding.fileNameTextView.text = getString(R.string.no_file_selected)			binding.fileNameTextView.isSelected = false			showToast(getString(R.string.selected_file_cleared))		}		binding.createZipMBtn.setOnClickListener {			when {				cacheFile != null -> {					createZipFile()				}				tempFiles.isNotEmpty() -> {					createZipFile()				}				cachedFiles.isNotEmpty() -> {					createZipFile()				}				else -> {					showToast(getString(R.string.file_picked_fail))				}			}		}		binding.create7zBtn.setOnClickListener {			when {				cacheFile != null -> {					create7zSingleFile()				}				tempFiles.isNotEmpty() -> {					create7zFile()				}				cachedFiles.isNotEmpty() -> {					create7zFile()				}				else -> {					showToast(getString(R.string.file_picked_fail))				}			}		}		if (requireActivity().intent?.action == Intent.ACTION_VIEW) {			val uri = requireActivity().intent.data			if (uri != null) {				selectedFileUri = uri				binding.createZipMBtn.isEnabled = true				// Display the file name from the intent				val fileName = getZipFileName(selectedFileUri)				val selectedFileText = getString(R.string.selected_file_text, fileName)				binding.fileNameTextView.text = selectedFileText				binding.fileNameTextView.isSelected = true			} else {				showToast(getString(R.string.file_picked_fail))			}		}		val intent = requireActivity().intent		if (intent.action == Intent.ACTION_SEND) {			val fileUri = intent.getParcelableExtra<Uri>(Intent.EXTRA_STREAM)			selectedFileUri = fileUri			if (fileUri != null) {				cacheFile = File(requireActivity().cacheDir, getZipFileName(fileUri))				cacheFile!!.outputStream().use { outputStream ->					requireActivity().contentResolver.openInputStream(fileUri)?.use { inputStream ->						inputStream.copyTo(outputStream)					}				}			}		} else if (intent.action == Intent.ACTION_SEND_MULTIPLE) {			val fileUris = intent.getParcelableArrayListExtra<Uri>(Intent.EXTRA_STREAM)			fileUris?.forEach { fileUri ->				val file = File(requireActivity().cacheDir, getZipFileName(fileUri))				file.outputStream().use { outputStream ->					requireActivity().contentResolver.openInputStream(fileUri)?.use { inputStream ->						inputStream.copyTo(outputStream)					}				}				tempFiles.add(file)			}		}		val savedDirectoryUri = sharedPreferences.getString("outputDirectoryUriZip", null)		if (savedDirectoryUri != null) {			outputDirectory = DocumentFile.fromTreeUri(requireContext(), Uri.parse(savedDirectoryUri))			val fullPath = outputDirectory?.uri?.path			val displayedPath = fullPath?.replace("/tree/primary:", "")			if (displayedPath != null) {				val directoryText = getString(R.string.directory_path, displayedPath)				binding.directoryTextView.text = directoryText			}		} else {			//do nothing		}		recyclerView = binding.recyclerViewFiles		recyclerView.layoutManager = LinearLayoutManager(requireContext())		// Replace getFilesInCacheDirectory with a function to get the initial list of files		val fileList = getFilesInCacheDirectory(requireContext().cacheDir)		adapter = FileAdapter(fileList, this, this)		recyclerView.adapter = adapter	}	private fun getFilesInCacheDirectory(directory: File): MutableList<File> {		val filesList = mutableListOf<File>()		// Recursive function to traverse the directory		fun traverseDirectory(file: File) {			if (file.isDirectory) {				file.listFiles()?.forEach {					traverseDirectory(it)				}			} else {				filesList.add(file)			}		}		traverseDirectory(directory)		return filesList	}	override fun onResume() {		super.onResume()		val fileList = getFilesInCacheDirectory(requireContext().cacheDir)		adapter.updateFileList(fileList)	}	override fun onFileClick(file: File) {		//open activity		val intent = Intent(requireContext(), PickedFilesActivity::class.java)		startActivity(intent)	}	@SuppressLint("NotifyDataSetChanged")	override fun onDeleteClick(file: File) {		val cacheFile = File(requireContext().cacheDir, file.name)		cacheFile.delete()		// use relative path to delete the file from cache directory		val relativePath = file.path.replace("${requireContext().cacheDir}/", "")		val fileToDelete = File(requireContext().cacheDir, relativePath)		fileToDelete.delete()		val parentFolder = fileToDelete.parentFile		if (parentFolder != null) {			if (parentFolder.listFiles()?.isEmpty() == true) {				parentFolder.delete()			}		}		adapter.fileList.remove(file)		adapter.notifyDataSetChanged()	}	private fun changeDirectoryFilesPicker() {		directoryFilesPicker.launch(null)	}	private fun openFile() {		val intent = Intent(Intent.ACTION_GET_CONTENT)		intent.type = "*/*"		intent.addCategory(Intent.CATEGORY_OPENABLE)		intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true)		pickFilesLauncher.launch(intent)	}	private fun chooseOutputDirectory() {		directoryPicker.launch(null)	}	private fun copyFilesToCache(directoryUri: Uri) {		binding.circularProgressBar.visibility = View.VISIBLE		val contentResolver = requireContext().contentResolver		// Create a DocumentFile from the directoryUri		val directory = DocumentFile.fromTreeUri(requireContext(), directoryUri)		// Save the directory name for later use		cachedDirectoryName = directory?.name		// Check if directory is null		if (directory != null && cachedDirectoryName != null) {			// Create a virtual directory in the cache			val cachedDirectory = File(requireContext().cacheDir, cachedDirectoryName!!)			cachedDirectory.mkdirs()			// Get all files recursively			val allFiles = mutableListOf<DocumentFile>()			getAllFilesInDirectory(directory, allFiles)			// Launch a coroutine in the IO dispatcher			lifecycleScope.launch(Dispatchers.IO) {				// Copy each file to the cache directory with the preserved folder structure				for (file in allFiles) {					val relativePath = getRelativePath(directory, file)					val outputFile = File(cachedDirectory, relativePath)					// Ensure parent directories are created					outputFile.parentFile?.mkdirs()					val inputStream = contentResolver.openInputStream(file.uri)					val outputStream = FileOutputStream(outputFile)					inputStream?.use { input ->						outputStream.use { output ->							input.copyTo(output)						}					}					cachedFiles.add(outputFile)				}				// Switch to the Main dispatcher to update the UI				withContext(Dispatchers.Main) {					val fileList = getFilesInCacheDirectory(requireContext().cacheDir)					adapter.updateFileList(fileList)					binding.circularProgressBar.visibility = View.GONE				}			}		}	}	private fun getRelativePath(baseDirectory: DocumentFile, file: DocumentFile): String {		// Get the relative path of the file with respect to the base directory		val basePath = baseDirectory.uri.path ?: ""		val filePath = file.uri.path ?: ""		return if (filePath.startsWith(basePath)) {			filePath.substring(basePath.length)		} else {			// Handle the case where the file is not within the base directory			file.name ?: ""		}	}	private val cachedDirectory: File? get() {		return if (cachedDirectoryName != null) {			File(requireContext().cacheDir, cachedDirectoryName!!)		} else {			null		}	}	private fun getAllFilesInDirectory(directory: DocumentFile?, fileList: MutableList<DocumentFile>) {		if (directory != null && directory.isDirectory) {			val files = directory.listFiles()			for (file in files) {				if (file.isFile) {					fileList.add(file)				} else if (file.isDirectory) {					// Recursively get files in child directories					getAllFilesInDirectory(file, fileList)				}			}		}	}	private fun getRelativePathForFile(baseDirectory: File, file: File): String {		val basePath = baseDirectory.path		val filePath = file.path		return if (filePath.startsWith(basePath)) {			filePath.substring(basePath.length)		} else {			file.name		}	}	//Not so happy with this function	//Sometimes it fails to create the 7z file	//I will try to improve it in the future	//But for now it works	private fun create7zSingleFile() {		binding.progressBarNI.visibility = View.VISIBLE		showPasswordInputDialog7z { password, _, level, solid, thread ->			CoroutineScope(Dispatchers.IO).launch {				try {					val tempZipFile = File(requireContext().cacheDir, "temp_archive.7z")					val outputFileName = getZipFileName(selectedFileUri)					withContext(Dispatchers.IO) {						RandomAccessFile(tempZipFile, "rw").use { raf ->							val outArchive = SevenZip.openOutArchive7z()							outArchive.setLevel(level)							outArchive.setSolid(solid)							outArchive.setThreadCount(thread)							outArchive.setHeaderEncryption(true)							val fileToArchive = cacheFile!!							outArchive.createArchive(RandomAccessFileOutStream(raf), 1,								object : IOutCreateCallback<IOutItem7z>, ICryptoGetTextPassword,									IOutFeatureSetEncryptHeader {									override fun cryptoGetTextPassword(): String? {										return password									}									override fun setOperationResult(operationResultOk: Boolean) {										// Track each operation result here									}									override fun setTotal(total: Long) {										CoroutineScope(Dispatchers.Main).launch {											binding.progressBarNI.max = total.toInt()										}									}									override fun setCompleted(complete: Long) {										CoroutineScope(Dispatchers.Main).launch {											binding.progressBarNI.progress = complete.toInt()										}									}									override fun getItemInformation(index: Int, outItemFactory: OutItemFactory<IOutItem7z>): IOutItem7z {										val item = outItemFactory.createOutItem()										if (fileToArchive.isDirectory) {											// Directory											item.propertyIsDir = true										} else {											// File											item.dataSize = fileToArchive.length()										}										item.propertyPath = fileToArchive.name										return item									}									override fun getStream(i: Int): RandomAccessFileInStream {										return RandomAccessFileInStream(RandomAccessFile(fileToArchive, "r"))									}									override fun setHeaderEncryption(enabled: Boolean) {										outArchive.setHeaderEncryption(enabled)									}								})							outArchive.close()						}					}					if (outputDirectory != null && tempZipFile.exists()) {						val outputUri = DocumentsContract.buildDocumentUriUsingTree(							outputDirectory!!.uri,							DocumentsContract.getTreeDocumentId(outputDirectory!!.uri))						val outputZipUri = DocumentsContract.createDocument(							requireActivity().contentResolver, outputUri, "application/x-7z-compressed", outputFileName.toString())						requireActivity().contentResolver.openOutputStream(outputZipUri!!, "w").use { outputStream ->							FileInputStream(tempZipFile).use { tempInputStream ->								val buffer = ByteArray(1024)								var bytesRead: Int								while (tempInputStream.read(buffer).also { bytesRead = it } != -1) {									outputStream!!.write(buffer, 0, bytesRead)								}							}						}						val cacheDir = requireContext().cacheDir						if (cacheDir.isDirectory) {							val children: Array<String> = cacheDir.list()!!							for (i in children.indices) {								File(cacheDir, children[i]).deleteRecursively()							}						}						// Notify the user about the success						withContext(Dispatchers.Main) {							showToast(getString(R.string.sevenz_creation_success))							binding.progressBarNI.visibility = View.GONE						}					}				} catch (e: SevenZipException) {					e.printStackTraceExtended()					withContext(Dispatchers.Main) {						// Notify the user about the error						showToast(getString(R.string.sevenz_creation_failed))						binding.progressBarNI.visibility = View.GONE					}				} catch (e: IOException) {					if (isNoStorageSpaceException(e)) {						withContext(Dispatchers.Main) {							binding.progressBar.visibility = View.GONE							showToast("No storage available")						}					} else {						showToast("${getString(R.string.extraction_failed)} ${e.message}")					}				} catch (e: OutOfMemoryError) {					e.printStackTrace()					withContext(Dispatchers.Main) {						// Notify the user about the error						showToast("Out of memory")						binding.progressBarNI.visibility = View.GONE					}				}			}		}	}	private fun create7zFile() {		binding.progressBarNI.visibility = View.VISIBLE		showPasswordInputDialog7z { password, archiveName, level, solid, thread ->			CoroutineScope(Dispatchers.IO).launch {				try {					val filesToArchive = tempFiles.ifEmpty { cachedFiles }					val tempZipFile = File(requireContext().cacheDir, "temp_archive.7z")					val outputFileName = "$archiveName.7z"					withContext(Dispatchers.IO) {						RandomAccessFile(tempZipFile, "rw").use { raf ->							val outArchive = SevenZip.openOutArchive7z()							outArchive.setLevel(level)							outArchive.setSolid(solid)							outArchive.setThreadCount(thread)							outArchive.setHeaderEncryption(true)							outArchive.createArchive(RandomAccessFileOutStream(raf), filesToArchive.size,								object : IOutCreateCallback<IOutItem7z>, ICryptoGetTextPassword,									IOutFeatureSetEncryptHeader {									override fun cryptoGetTextPassword(): String? {										return password									}									override fun setOperationResult(operationResultOk: Boolean) { }									override fun setTotal(total: Long) {										CoroutineScope(Dispatchers.Main).launch {											binding.progressBarNI.max = total.toInt()										}									}									override fun setCompleted(complete: Long) {										CoroutineScope(Dispatchers.Main).launch {											binding.progressBarNI.progress = complete.toInt()										}									}									override fun getItemInformation(index: Int, outItemFactory: OutItemFactory<IOutItem7z>): IOutItem7z {										val item = outItemFactory.createOutItem()										val file = filesToArchive[index]										if (file.isDirectory) {											// Directory											item.propertyIsDir = true										} else {											// File											item.dataSize = file.length()										}										item.propertyPath = file.name										// Set the file structure inside the archive										if (cachedFiles.contains(file)) {											val relativePath = getRelativePathForFile(cachedDirectory!!, file)											item.propertyPath = relativePath + (if (file.isDirectory) File.separator else "")										} else {											// Use the file name for tempFiles											item.propertyPath = file.name										}										return item									}									override fun getStream(i: Int): ISequentialInStream {										return RandomAccessFileInStream(RandomAccessFile(filesToArchive[i], "r"))									}									override fun setHeaderEncryption(enabled: Boolean) {										outArchive.setHeaderEncryption(enabled)									}								})							outArchive.close()						}					}					if (outputDirectory != null && tempZipFile.exists()) {						val outputUri = DocumentsContract.buildDocumentUriUsingTree(							outputDirectory!!.uri,							DocumentsContract.getTreeDocumentId(outputDirectory!!.uri))						val outputZipUri = DocumentsContract.createDocument(							requireActivity().contentResolver, outputUri, "application/x-7z-compressed", outputFileName)						requireActivity().contentResolver.openOutputStream(outputZipUri!!, "w").use { outputStream ->							FileInputStream(tempZipFile).use { tempInputStream ->								val buffer = ByteArray(1024)								var bytesRead: Int								while (tempInputStream.read(buffer).also { bytesRead = it } != -1) {									outputStream!!.write(buffer, 0, bytesRead)								}							}						}						val cacheDir = requireContext().cacheDir						if (cacheDir.isDirectory) {							val children: Array<String> = cacheDir.list()!!							for (i in children.indices) {								File(cacheDir, children[i]).deleteRecursively()							}						}						// Notify the user about the success						withContext(Dispatchers.Main) {							showToast(getString(R.string.sevenz_creation_success))							binding.progressBarNI.visibility = View.GONE						}					}				} catch (e: SevenZipException) {					e.printStackTraceExtended()					withContext(Dispatchers.Main) {						// Notify the user about the error						showToast(getString(R.string.sevenz_creation_failed))						binding.progressBarNI.visibility = View.GONE					}				} catch (e: IOException) {					if (isNoStorageSpaceException(e)) {						withContext(Dispatchers.Main) {							binding.progressBar.visibility = View.GONE							showToast("No storage available")						}					} else {						showToast("${getString(R.string.extraction_failed)} ${e.message}")					}				} catch (e: OutOfMemoryError) {					e.printStackTrace()					withContext(Dispatchers.Main) {						// Notify the user about the error						showToast("Out of memory")						binding.progressBarNI.visibility = View.GONE					}				}			}		}	}	private fun isNoStorageSpaceException(e: IOException): Boolean {		return e.message?.contains("ENOSPC") == true || e.cause is ErrnoException && (e.cause as ErrnoException).errno == OsConstants.ENOSPC	}	private fun createZipFile() {		showCompressionSettingsDialog { archiveName, password, compressionMethod, compressionLevel, isEncrypted ,encryptionMethod, aesStrength, _ ->			CoroutineScope(Dispatchers.IO).launch {				try {					showProgressBar(true)					var outputFileName = archiveName.ifEmpty { getZipFileName(selectedFileUri) ?: "outputZip" }					if (outputFileName.isEmpty()) {						// Use default name if empty						outputFileName = getString(R.string.output_file_name)					} else if (!outputFileName.endsWith(".zip", ignoreCase = true)) {						// Automatically add .zip extension						outputFileName += ".zip"					}					val zipParameters = ZipParameters()					zipParameters.compressionMethod = compressionMethod					zipParameters.compressionLevel = compressionLevel					zipParameters.encryptionMethod = if (isEncrypted) encryptionMethod else null					zipParameters.isEncryptFiles = isEncrypted					zipParameters.aesKeyStrength = if (isEncrypted) aesStrength else null					val tempZipFile = File(requireContext().cacheDir, "temp_archive.zip")					val zipFile = ZipFile(tempZipFile)					if (isEncrypted) {						zipFile.setPassword(password?.toCharArray())					}					val cachedDirectory = cachedDirectory					try {						when {							cachedDirectory != null -> {								zipFile.addFolder(cachedDirectory, zipParameters)							}							tempFiles.isNotEmpty() -> {								zipFile.addFiles(tempFiles, zipParameters)							}							cacheFile != null -> {								zipFile.addFile(cacheFile, zipParameters)							}							else -> {								showToast(getString(R.string.please_select_files))							}						}						showToast(getString(R.string.zip_creation_success))						showExtractionCompletedSnackbar(outputDirectory)					} catch (e: ZipException) {						showToast("${getString(R.string.zip_creation_failed)} ${e.message}")						showProgressBar(false)					} finally {						when {							cachedFiles.isNotEmpty() -> {								for (cachedFile in cachedFiles) {									cachedFile.delete()								}								cachedFiles.clear()							}							tempFiles.isNotEmpty() -> {								for (tempFile in tempFiles) {									tempFile.delete()								}								tempFiles.clear()							}						}						showProgressBar(false)					}					if (outputDirectory != null && tempZipFile.exists()) {						val outputUri = DocumentsContract.buildDocumentUriUsingTree(							outputDirectory!!.uri,							DocumentsContract.getTreeDocumentId(outputDirectory!!.uri)						)						val outputZipUri = DocumentsContract.createDocument(							requireActivity().contentResolver,							outputUri,							"application/zip",							outputFileName						)						requireActivity().contentResolver.openOutputStream(outputZipUri!!, "w")							.use { outputStream ->								FileInputStream(tempZipFile).use { tempInputStream ->									val buffer = ByteArray(1024)									var bytesRead: Int									while (tempInputStream.read(buffer)											.also { bytesRead = it } != -1									) {										outputStream!!.write(buffer, 0, bytesRead)									}								}							}						showExtractionCompletedSnackbar(outputDirectory)						showToast(getString(R.string.zip_creation_success))					} else {						showToast(getString(R.string.select_output_directory))					}					if (tempZipFile.exists())						tempZipFile.delete()				} catch (e: Exception) {					e.printStackTrace()				}			}		}	}	private fun createSplitZipFile(archiveName: String, password: String, compressionMethod: CompressionMethod, compressionLevel: CompressionLevel, isEncrypted: Boolean, encryptionMethod: EncryptionMethod?, aesStrength: AesKeyStrength?, splitZipSize: Long?) {		CoroutineScope(Dispatchers.IO).launch {			val baseFileName = archiveName.ifEmpty { getZipFileName(selectedFileUri) ?: "splitArchive" }.removeSuffix(".zip")			try {				showProgressBar(true)				val splitZipSizeBytes = (splitZipSize?.times(1024) ?: 10) * 1024				val zipParameters = ZipParameters()				zipParameters.compressionMethod = compressionMethod				zipParameters.compressionLevel = compressionLevel				zipParameters.encryptionMethod = if (isEncrypted) encryptionMethod else null				zipParameters.isEncryptFiles = isEncrypted				zipParameters.aesKeyStrength = if (isEncrypted) aesStrength else null				val tempZipFile = File(requireContext().cacheDir, "$baseFileName.zip")				val zipFile = ZipFile(tempZipFile)				if (isEncrypted) {					zipFile.setPassword(password.toCharArray())				}				val cachedDirectory = cachedDirectory				try {					when {						cachedDirectory != null -> {							zipFile.createSplitZipFileFromFolder(cachedDirectory, zipParameters, true, splitZipSizeBytes)						}						tempFiles.isNotEmpty() -> {							zipFile.createSplitZipFile(tempFiles, zipParameters, true, splitZipSizeBytes)						}						cacheFile != null -> {							cacheFile?.let { singleFile ->								val fileList = listOf(singleFile)								zipFile.createSplitZipFile(fileList, zipParameters, true, splitZipSizeBytes)							}						}						else -> {							showToast(getString(R.string.please_select_files))						}					}					val splitFiles = File(tempZipFile.parent!!).listFiles { _, name -> name.startsWith("$baseFileName.z") }					val lastPartIndex = splitFiles?.mapNotNull { it.name.substringAfterLast(".z").toIntOrNull() }?.maxOrNull() ?: 0					val nextIndex = if (lastPartIndex < 9) {						lastPartIndex + 1 // Increment by 1 for parts less than 9					} else {						lastPartIndex + 1 // Increment by 1 for parts 9 or greater					}					val lastPartIndexString = if (nextIndex < 10) {						String.format("%02d", nextIndex)					} else {						nextIndex.toString()					}					val lastPart = File(tempZipFile.parent, "$baseFileName.z$lastPartIndexString")					tempZipFile.renameTo(lastPart)					showToast(getString(R.string.zip_creation_success))					showExtractionCompletedSnackbar(outputDirectory)				} catch (e: ZipException) {					showToast("${getString(R.string.zip_creation_failed)} ${e.message}")					showProgressBar(false)				} finally {					when {						cachedFiles.isNotEmpty() -> {							for (cachedFile in cachedFiles) {								cachedFile.delete()							}							cachedFiles.clear()						}						tempFiles.isNotEmpty() -> {							for (tempFile in tempFiles) {								tempFile.delete()							}							tempFiles.clear()						}					}					showProgressBar(false)				}				val cacheFiles = requireContext().cacheDir.listFiles()				cacheFiles?.forEach { file ->					if (file.extension.matches(Regex("z\\d{2}"))) {						val outputUri = DocumentsContract.buildDocumentUriUsingTree(outputDirectory!!.uri, DocumentsContract.getTreeDocumentId(							outputDirectory!!.uri))						val outputZipUri = DocumentsContract.createDocument(requireActivity().contentResolver, outputUri, "application/octet-stream", file.name)						requireActivity().contentResolver.openOutputStream(outputZipUri!!, "w").use { outputStream ->							FileInputStream(file).use { inputStream ->								if (outputStream != null) {									inputStream.copyTo(outputStream)								}							}						}					}				}				showExtractionCompletedSnackbar(outputDirectory)				showToast(getString(R.string.zip_creation_success))			} catch (e: Exception) {				e.printStackTrace()			}		}	}	private suspend fun showProgressBar(show: Boolean) {		withContext(Dispatchers.Main) {			binding.progressBar.visibility = if (show) View.VISIBLE else View.GONE		}	}	private suspend fun showExtractionCompletedSnackbar(outputDirectory: DocumentFile?) {		withContext(Dispatchers.Main) {			binding.progressBar.visibility = View.GONE			// Show a snackbar with a button to open the ZIP file			val snackbar = Snackbar.make(binding.root, getString(R.string.zip_creation_success), Snackbar.LENGTH_LONG)			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {				snackbar.setAction(getString(R.string.open_folder)) {					val intent = Intent(Intent.ACTION_VIEW)					intent.setDataAndType(outputDirectory?.uri, DocumentsContract.Document.MIME_TYPE_DIR)					intent.flags = Intent.FLAG_GRANT_READ_URI_PERMISSION					startActivity(intent)				}			}			snackbar.show()		}	}	private fun getZipFileName(selectedFileUri: Uri?): String? {		if (selectedFileUri != null) {			val cursor = requireActivity().contentResolver.query(selectedFileUri, null, null, null, null)			cursor?.use {				if (it.moveToFirst()) {					val displayNameIndex = it.getColumnIndex(OpenableColumns.DISPLAY_NAME)					if (displayNameIndex != -1) {						return it.getString(displayNameIndex)					}				}			}		}		return null	}	private fun showCompressionSettingsDialog(onCompressionSettingsEntered: (String, String?, CompressionMethod, CompressionLevel, Boolean, EncryptionMethod?, AesKeyStrength?, Long?) -> Unit) {		val layoutInflater = LayoutInflater.from(requireContext())		val customView = layoutInflater.inflate(R.layout.zip_settings_dialog, null)		val compressionMethodSpinner = customView.findViewById<Spinner>(R.id.compression_method_input)		val compressionLevelSpinner = customView.findViewById<Spinner>(R.id.compression_level_input)		val encryptionMethodSpinner = customView.findViewById<Spinner>(R.id.encryption_method_input)		val encryptionStrengthSpinner = customView.findViewById<Spinner>(R.id.encryption_strength_input)		val passwordInput = customView.findViewById<EditText>(R.id.passwordEditText)		val zipNameEditText = customView.findViewById<EditText>(R.id.zipNameEditText)		val splitZipCheckbox = customView.findViewById<CheckBox>(R.id.splitZipCheckbox)		val splitSizeInput = customView.findViewById<EditText>(R.id.splitSizeEditText)		splitZipCheckbox.setOnCheckedChangeListener { _, isChecked ->			splitSizeInput.isEnabled = isChecked		}		val compressionMethods = CompressionMethod.values().filter { it != CompressionMethod.AES_INTERNAL_ONLY }.map { it.name }.toTypedArray()		val compressionMethodAdapter = ArrayAdapter(requireContext(), android.R.layout.simple_spinner_item, compressionMethods)		compressionMethodAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)		compressionMethodSpinner.adapter = compressionMethodAdapter		val compressionLevels = CompressionLevel.values().map { it.name }.toTypedArray()		val compressionLevelAdapter = ArrayAdapter(requireContext(), android.R.layout.simple_spinner_item, compressionLevels)		compressionLevelAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)		compressionLevelSpinner.adapter = compressionLevelAdapter		val encryptionMethods = EncryptionMethod.values().map { it.name }.toTypedArray()		val encryptionMethodAdapter = ArrayAdapter(requireContext(), android.R.layout.simple_spinner_item, encryptionMethods)		encryptionMethodAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)		encryptionMethodSpinner.adapter = encryptionMethodAdapter		val encryptionStrengths = AesKeyStrength.values().filter { it != AesKeyStrength.KEY_STRENGTH_192 }.map { it.name }.toTypedArray()		val encryptionStrengthAdapter = ArrayAdapter(requireContext(), android.R.layout.simple_spinner_item, encryptionStrengths)		encryptionStrengthAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)		encryptionStrengthSpinner.adapter = encryptionStrengthAdapter		val filesToArchive = tempFiles.ifEmpty { cachedFiles }		val builder = MaterialAlertDialogBuilder(requireContext())		builder.setView(customView)		builder.setPositiveButton(getString(R.string.ok)) { _, _ ->			val defaultName = if (filesToArchive.isNotEmpty()) {				filesToArchive[0].nameWithoutExtension			} else {				""			}			val archiveName = zipNameEditText.text.toString().ifBlank { defaultName }			val password = passwordInput.text.toString()			val isEncryptionEnabled = password.isNotEmpty()			val selectedCompressionMethod = CompressionMethod.valueOf(compressionMethods[compressionMethodSpinner.selectedItemPosition])			val selectedCompressionLevel = CompressionLevel.valueOf(compressionLevels[compressionLevelSpinner.selectedItemPosition])			val selectedEncryptionMethod = if (encryptionMethodSpinner.selectedItemPosition != 0) {				EncryptionMethod.valueOf(encryptionMethods[encryptionMethodSpinner.selectedItemPosition])			} else {				null			}			val selectedEncryptionStrength = if (selectedEncryptionMethod != null && selectedEncryptionMethod != EncryptionMethod.NONE) {				AesKeyStrength.valueOf(encryptionStrengths[encryptionStrengthSpinner.selectedItemPosition])			} else {				null			}			val splitZipSize = if (splitZipCheckbox.isChecked) splitSizeInput.text.toString().toLongOrNull() else null			onCompressionSettingsEntered.invoke(				archiveName,				password.takeIf { isEncryptionEnabled },				selectedCompressionMethod,				selectedCompressionLevel,				isEncryptionEnabled,				selectedEncryptionMethod,				selectedEncryptionStrength,				splitZipSize			)			// Call createSplitZipFile function only if splitZipCheckbox is checked			if (splitZipCheckbox.isChecked) {				createSplitZipFile(archiveName, password, selectedCompressionMethod, selectedCompressionLevel, isEncryptionEnabled, selectedEncryptionMethod, selectedEncryptionStrength, splitZipSize)			}		}		builder.setNegativeButton(getString(R.string.cancel)) { dialog, _ ->			dialog.dismiss()		}		// Add listener to encryption method spinner to enable/disable password input		encryptionMethodSpinner.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {			override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {				val selectedEncryptionMethod = EncryptionMethod.valueOf(encryptionMethods[position])				passwordInput.isEnabled = selectedEncryptionMethod != EncryptionMethod.NONE				// Enable/disable encryption strength spinner based on selected encryption method				encryptionStrengthSpinner.isEnabled = selectedEncryptionMethod == EncryptionMethod.AES			}			override fun onNothingSelected(parent: AdapterView<*>?) {				// Do nothing			}		}		builder.show()	}	private fun showPasswordInputDialog7z(onPasswordEntered: (String?, String, Int, Boolean, Int) -> Unit) {		val layoutInflater = LayoutInflater.from(requireContext())		val customView = layoutInflater.inflate(R.layout.seven_z_option_dialog, null)		val passwordEditText = customView.findViewById<EditText>(R.id.passwordEditText)		val compressionSpinner = customView.findViewById<Spinner>(R.id.compressionSpinner)		val solidCheckBox = customView.findViewById<CheckBox>(R.id.solidCheckBox)		val threadCountEditText = customView.findViewById<EditText>(R.id.threadCountEditText)		val archiveNameEditText = customView.findViewById<EditText>(R.id.archiveNameEditText)		val filesToArchive = tempFiles.ifEmpty { cachedFiles }		MaterialAlertDialogBuilder(requireContext())			.setView(customView)			.setPositiveButton(getString(R.string.ok)) { _, _ ->				val defaultName = if (filesToArchive.isNotEmpty()) {					filesToArchive[0].nameWithoutExtension				} else {					"archive"				}				val archiveName = archiveNameEditText.text.toString().ifBlank { defaultName }				val password = passwordEditText.text.toString()				val compressionLevel = when (compressionSpinner.selectedItemPosition) {					0 -> 0					1 -> 1					2 -> 3					3 -> 5					4 -> 7					5 -> 9					else -> -1				}				val solid = solidCheckBox.isChecked				val threadCount = threadCountEditText.text.toString().toIntOrNull() ?: -1				onPasswordEntered.invoke(					password.ifBlank { null },					archiveName,					compressionLevel,					solid,					threadCount				)			}			.setNegativeButton(getString(R.string.no_password)) { _, _ ->				val defaultName = if (filesToArchive.isNotEmpty()) {					filesToArchive[0].nameWithoutExtension				} else {					"archive"				}				val archiveName = archiveNameEditText.text.toString().ifBlank { defaultName }				val compressionLevel = when (compressionSpinner.selectedItemPosition) {					0 -> 0					1 -> 1					2 -> 3					3 -> 5					4 -> 7					5 -> 9					else -> -1				}				val solid = solidCheckBox.isChecked				val threadCount = threadCountEditText.text.toString().toIntOrNull() ?: -1				onPasswordEntered.invoke(					null,					archiveName,					compressionLevel,					solid,					threadCount				)			}			.show()	}	private fun showToast(message: String) {		// Show toast on the main thread		requireActivity().runOnUiThread {			Toast.makeText(context, message, Toast.LENGTH_SHORT).show()		}	}	companion object {		private const val PREFS_NAME = "ZipPrefs"	}}